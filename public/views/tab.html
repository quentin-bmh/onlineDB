<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Tableau de Synthèse ADV</title>
    <style>
            /* Styles pour les couleurs PDF (utilisés dans la légende) */
        .color-box {
            display: inline-block;
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border: 1px solid #ccc;
            vertical-align: middle;
        }
        .bon { background-color: #4CAF50; /* Vert */ }
        .correct { background-color: #FFEB3B; /* Jaune */ }
        .acoriger { background-color: #F44336; /* Rouge */ }
        .aremplacer { background-color: #000000; /* Noir */ }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>
</head>
<body>
    <button onclick="lancerCalculEtAffichage(false)">1. Afficher Tableau Global (Console)</button>
    <button onclick="lancerCalculEtAffichage(true)">Synthèse Adv</button>
    <button id="btn-voie">Synthèse Voies</button>
    <script src="/js/notes.js"></script> 
    <script>

        const COULEURS = {
            bon: { hex: '#4CAF50', text: 'Bon (Vert)' }, 
            correct: { hex: '#FFEB3B', text: 'Correct (Jaune)' }, 
            acoriger: { hex: '#F44336', text: 'À corriger (Rouge)' }, 
            aremplacer: { hex: '#000000', text: 'À remplacer (Noir)' }, 
            // 'n/a (to)': { hex: '#CCCCCC', text: 'N/A (Gris)' }, 
            'n/a': { hex: '#CCCCCC', text: 'N/A (Gris)' }, 
            inconnu: { hex: '#FF9800', text: 'Inconnu (Orange)' },
            erreur: { hex: '#999999', text: 'Erreur (Gris Foncé)' }
        };
        document.getElementById('btn-voie').addEventListener('click', async () => {
            const resultats = await calculerNotesToutesVoies();
            if (resultats.length > 0) {
                genererRapportVoies();
            }
        });

        async function genererRapportVoies() {
            const resultats = await calculerNotesToutesVoies();
            if (!resultats || resultats.length === 0) return;

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const pageWidth = doc.internal.pageSize.getWidth();

            const STYLE = {
                bleuA2C: [0, 85, 150],
                logoUrl: "/assets/logo_a2c.png"
            };
            try {
                doc.addImage(STYLE.logoUrl, 'PNG', 14, 10, 45, 0); 
            } catch (e) {
                console.warn("Logo non trouvé.");
            }
            doc.setFont("helvetica", "bold");
            doc.setFontSize(18);
            doc.setTextColor(STYLE.bleuA2C[0], STYLE.bleuA2C[1], STYLE.bleuA2C[2]);
            const titre = "Synthèse Voies";
            const titreWidth = doc.getTextWidth(titre);
            doc.text(titre, pageWidth - 14 - titreWidth, 25);

            doc.setFont("helvetica", "normal");
            doc.setFontSize(10);
            doc.setTextColor(100, 100, 100);
            const dateStr = `Daté du : ${new Date().toLocaleDateString('fr-FR')} à ${new Date().toLocaleTimeString('fr-FR')}`;
            const dateWidth = doc.getTextWidth(dateStr);
            doc.text(dateStr, pageWidth - 14 - dateWidth, 32);
            doc.setDrawColor(STYLE.bleuA2C[0], STYLE.bleuA2C[1], STYLE.bleuA2C[2]);
            doc.setLineWidth(0.8);
            doc.line(14, 48, pageWidth - 14, 48);

            const headers = [["Voie", "Écartement", "Gauche"]];
            const body = resultats.map(v => [v.nom || "Inconnu", "", ""]);

            doc.autoTable({
                head: headers,
                body: body,
                startY: 55,
                theme: 'grid',
                styles: { fontSize: 10, cellPadding: 4, halign: 'center', valign: 'middle' },
                headStyles: { fillColor: [245, 245, 245], textColor: [50, 50, 50], fontStyle: 'bold' },
                columnStyles: { 0: { halign: 'left', fontStyle: 'bold' } },
                didParseCell: (data) => {
                    if (data.section === 'body') {
                        const rowIndex = data.row.index;
                        const colIndex = data.column.index;
                        const rowData = resultats[rowIndex];
                        
                        let note = colIndex === 0 ? rowData.globale : (colIndex === 1 ? rowData.ecartement : rowData.gauche);
                        const config = COULEURS[note] || { hex: '#999999' };

                        data.cell.styles.fillColor = config.hex;
                        data.cell.styles.textColor = (note === 'aremplacer') ? [255, 255, 255] : [0, 0, 0];
                    }
                }
            });

            // LÉGENDE
            let finalY = doc.lastAutoTable.finalY + 15;
            if (finalY > 270) { doc.addPage(); finalY = 20; }

            doc.setFont("helvetica", "bold");
            doc.setFontSize(11);
            doc.setTextColor(50, 50, 50);
            doc.text("Légende des états :", 14, finalY);

            const labelsLegende = {
                'bon': 'Bon',
                'correct': 'Correct',
                'acoriger': 'À corriger',
                'aremplacer': 'À remplacer',
                'erreur': 'Erreur / Inconnu'
            };

            let currentY = finalY + 8;
            Object.keys(labelsLegende).forEach(key => {
                const couleurHex = (COULEURS[key] && COULEURS[key].hex) ? COULEURS[key].hex : '#999999';
                
                doc.setFillColor(couleurHex);
                doc.setDrawColor(180, 180, 180);
                doc.rect(14, currentY - 4, 5, 5, 'FD'); 
                
                doc.setFont("helvetica", "normal");
                doc.setFontSize(9);
                doc.setTextColor(80, 80, 80);
                
                let txt = labelsLegende[key];
                
                doc.text(txt, 22, currentY);
                currentY += 7;
            });

            doc.save(`Synthese_Voies_${new Date().toISOString().slice(0,10)}.pdf`);
        }

        function afficherTableauGlobalConsole(resultatsLot) {
            console.log(`\n============================================`);
            console.log(` SYNTHÈSE GLOBALE DE ${resultatsLot.length} ADV`);
            console.log(`============================================`);
            console.table(resultatsLot);
        }
        
        function genererPDF(resultatsLot) {
            if (!window.jspdf || !window.jspdf.jsPDF) {
                console.error("Erreur: La librairie jsPDF n'est pas chargée.");
                return;
            }
            if (!resultatsLot || resultatsLot.length === 0) return;

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF(); 
            const pageWidth = doc.internal.pageSize.getWidth();

            const STYLE = {
                bleuA2C: [0, 85, 150],
                logoUrl: "/assets/logo_a2c.png"
            };

            const SEVERITE = { 'aremplacer': 4, 'acoriger': 3, 'correct': 2, 'bon': 1, 'inconnu': 0, 'erreur': 0 };

            try {
                doc.addImage(STYLE.logoUrl, 'PNG', 14, 10, 45, 0); 
            } catch (e) {
                console.warn("Logo non trouvé.");
            }
            doc.setFont("helvetica", "bold");
            doc.setFontSize(18);
            doc.setTextColor(STYLE.bleuA2C[0], STYLE.bleuA2C[1], STYLE.bleuA2C[2]);
            const titre = "Synthèse ADV";
            const titreWidth = doc.getTextWidth(titre);
            doc.text(titre, pageWidth - 14 - titreWidth, 25);
            doc.setFont("helvetica", "normal");
            doc.setFontSize(10);
            doc.setTextColor(100, 100, 100);
            const dateStr = `Daté du : ${new Date().toLocaleDateString('fr-FR')} à ${new Date().toLocaleTimeString('fr-FR')}`;
            const dateWidth = doc.getTextWidth(dateStr);
            doc.text(dateStr, pageWidth - 14 - dateWidth, 32);
            // BARRE DE SÉPARATION
            doc.setDrawColor(STYLE.bleuA2C[0], STYLE.bleuA2C[1], STYLE.bleuA2C[2]);
            doc.setLineWidth(0.8);
            doc.line(14, 48, pageWidth - 14, 48);
            
            const headers = ["ADV", "Croisement", "Écartement", "Attaches / Rails", "Bois / Joints", "Demi-Aiguillage"];
            const noteKeys = ["Croisement", "Écartement", "Attaches / Rails", "Bois / Joints", "Demi-Aiguillage"];

            const body = resultatsLot.map(row => {
                const rowData = [row.ADV];
                noteKeys.forEach(key => {
                    const val = String(row[key]);
                    rowData.push(val.includes('N/A') || val.includes('ERREUR') ? val : '');
                });
                return rowData;
            });

            // TABLEAU
            doc.autoTable({
                head: [headers],
                body: body,
                startY: 55,
                theme: 'grid',
                styles: { fontSize: 8, cellPadding: 2, halign: 'center', valign: 'middle' },
                headStyles: { fillColor: [245, 245, 245], textColor: [50, 50, 50], fontStyle: 'bold' },
                columnStyles: { 0: { halign: 'left', fontStyle: 'bold', cellWidth: 40 } },
                didParseCell: (data) => {
                    if (data.section === 'body') {
                        const rowIndex = data.row.index;
                        const colIndex = data.column.index;
                        const rowObj = resultatsLot[rowIndex];
                        
                        let notePourCouleur;

                        if (colIndex === 0) {
                            let pireNote = 'bon';
                            noteKeys.forEach(key => {
                                const noteCat = String(rowObj[key]).toLowerCase().split('(')[0].trim();
                                if (SEVERITE[noteCat] > SEVERITE[pireNote]) {
                                    pireNote = noteCat;
                                }
                            });
                            notePourCouleur = pireNote;
                        } else {
                            notePourCouleur = String(rowObj[noteKeys[colIndex - 1]]).toLowerCase().split('(')[0].trim();
                        }
                        const config = COULEURS[notePourCouleur] || { hex: '#999999' };
                        data.cell.styles.fillColor = config.hex;                        
                        if (notePourCouleur === 'aremplacer' || notePourCouleur === 'erreur') {
                            data.cell.styles.textColor = [255, 255, 255];
                        } else {
                            data.cell.styles.textColor = [0, 0, 0];
                        }
                    }
                }
            });

            // LÉGENDE
            let finalY = doc.lastAutoTable.finalY + 10;
            if (finalY > 170) { doc.addPage(); finalY = 20; }

            doc.setFont("helvetica", "bold");
            doc.setFontSize(10);
            doc.setTextColor(50, 50, 50);
            doc.text("Légende des états :", 14, finalY);

            const labelsLegende = {
                'bon': 'Bon',
                'correct': 'Correct',
                'acoriger': 'À corriger',
                'aremplacer': 'À remplacer',
                'erreur': 'Erreur / Donnée manquante'
            };

            let currentY = finalY + 7;
            Object.keys(labelsLegende).forEach(key => {
                const couleurHex = COULEURS[key] ? COULEURS[key].hex : '#999999';
                doc.setFillColor(couleurHex);
                doc.setDrawColor(180, 180, 180);
                doc.rect(14, currentY - 3.5, 4, 4, 'FD'); 
                
                doc.setFont("helvetica", "normal");
                doc.setFontSize(8);
                doc.setTextColor(80, 80, 80);
                let txt = labelsLegende[key];
                
                doc.text(txt, 20, currentY);
                currentY += 6;
            });

            doc.save(`Rapport_Synthese_ADV_${new Date().toISOString().slice(0, 10)}.pdf`);
        }
        async function lancerCalculEtAffichage(isPDF) {
            if (typeof lancerCalculPourTousLesAdv !== 'function') {
                 console.error("Erreur: La fonction lancerCalculPourTousLesAdv est manquante. Vérifiez le chemin /js/notes.js.");
                 return;
            }            
            try {
                const resultatsLot = await lancerCalculPourTousLesAdv();

                if (!resultatsLot || resultatsLot.length === 0) {
                     console.warn("Aucun résultat à afficher ou télécharger.");
                     return;
                }
                afficherTableauGlobalConsole(resultatsLot);
                if (isPDF) {
                    genererPDF(resultatsLot);
                }
            } catch (error) {
                console.error("Erreur critique lors du processus global :", error);
            }
        }

        
        function lancerTestAutomatique() {
            if (typeof lancerCalculGlobalPourTest === 'function') {
                lancerCalculGlobalPourTest(ADV_TEST_NAME, ADV_TEST_TYPE);
            } else {
                console.warn("La fonction lancerCalculGlobalPourTest n'est pas disponible.");
            }
        }
        
        const ADV_TEST_NAME = "BS Test";
        const ADV_TEST_TYPE = "bs"; 


        let advGlobalData = {
            advName: null,
            advType: null,
            notesHorsDa: null,
            notesDA: null
        };
        
        function traiterAdvUnique(name, type) {
            const advName = name.trim();
            const advType = type.trim().toLowerCase();
            const encodedName = encodeURIComponent(advName);

            // Initialisation des notes HORS DA par défaut
            let notesHorsDa = {
                advName: advName,
                advType: advType.toUpperCase(),
                croisement: 'inconnu',
                ecartement: 'inconnu',
                attache_rails: 'inconnu',
                bois_joints: 'inconnu',
            };
            let notesDA = { demi_aiguillage: 'N/A (TO)' }; // Défaut pour TO

            // Promesse pour les données ADV principales
            const advDataPromise = fetch(`/api/${advType}/${encodedName}`)
                .then(res => {
                    if (!res.ok) throw new Error(`Erreur HTTP (ADV): ${res.status}`);
                    return res.json();
                })
                .then(data => Array.isArray(data) ? data[0] : data)
                .catch(err => {
                    console.error(`Erreur chargement ADV (${advName}):`, err);
                    return null;
                });

            let daDataPromise = Promise.resolve(null);
            
            // Charger les données DA seulement pour BS et TJ
            if (advType === 'bs' || advType === 'tj') {
                daDataPromise = fetch(`/api/da?adv=${encodedName}`)
                    .then(res => {
                        if (!res.ok) throw new Error(`Erreur HTTP (DA): ${res.status}`);
                        return res.json();
                    })
                    .catch(err => {
                        console.warn(`Avertissement: Données DA non trouvées ou erreur pour ${advName}.`);
                        return []; 
                    });
            }

            return Promise.all([advDataPromise, daDataPromise]).then(([advData, dataDA]) => {
                if (advData) {
                    // Calcul HORS DA (met à jour notesHorsDa)
                    notesHorsDa = calculNoteHorsDa(advData);

                    // Calcul DA
                    if (advType === 'bs' || advType === 'tj') {
                        if (dataDA && dataDA.length > 0) {
                            notesDA = calculNoteDa(dataDA, advType);
                        } else {
                            notesDA = { demi_aiguillage: 'inconnu' }; 
                        }
                    }
                }

                // Assemblage du résultat final pour cet ADV
                return {
                    ADV: notesHorsDa.advName,
                    Croisement: notesHorsDa.croisement,
                    Écartement: notesHorsDa.ecartement,
                    "Attaches / Rails": notesHorsDa.attache_rails,
                    "Bois / Joints": notesHorsDa.bois_joints,
                    "Demi-Aiguillage": notesDA.demi_aiguillage
                };
            });
        }
        
        async function lancerCalculPourTousLesAdv(callbackPDF = null) {
             console.log(`\n============================================`);
             console.log(` CHARGEMENT ET CALCUL DE TOUS LES ADV`);
             console.log(`============================================`);

             // Vérification que les seuils sont chargés avant de commencer
             if (Object.keys(seuilsTransformed).length === 0) {
                 console.error("ATTENTION: Les seuils ne sont pas encore chargés. Veuillez réessayer.");
                 return;
             }

             let advList;
             try {
                 // 1. Récupération de la liste complète des ADV
                 const response = await fetch('/api/general_data');
                 if (!response.ok) {
                     throw new Error(`Erreur HTTP lors du chargement de la liste ADV: ${response.status}`);
                 }
                 advList = await response.json();
             } catch (error) {
                 console.error("Erreur fatale lors de la récupération de la liste des ADV:", error);
                 return;
             }

             if (!advList || advList.length === 0) {
                 console.warn("Aucun ADV trouvé via /api/general_data.");
                 return;
             }
             
             console.log(`${advList.length} ADV à traiter...`);
             
             // 2. Préparation des Promesses de Calcul pour chaque ADV
             const promesses = advList.map(item => {
                 // Le type doit être en minuscules pour les routes API (ex: /api/bs/)
                 const typeLowerCase = item.type ? item.type.toLowerCase() : 'inconnu';
                 
                 // item.adv est le nom de l'ADV
                 // On appelle la fonction de calcul unitaire asynchrone.
                 return traiterAdvUnique(item.adv, typeLowerCase);
             });
             
             // 3. Exécution de toutes les promesses en parallèle (Promise.allSettled gère les échecs)
             const resultatsLotSettled = await Promise.allSettled(promesses);

             const resultatsLot = [];
             resultatsLotSettled.forEach(result => {
                 if (result.status === 'fulfilled') {
                     resultatsLot.push(result.value);
                 } else {
                     // En cas d'échec (ex: ADV non trouvé ou erreur API), on ajoute une ligne d'erreur
                     console.error(`Échec du traitement pour un ADV. Raison:`, result.reason);
                     // Crée un objet d'erreur pour le tableau final
                     resultatsLot.push({
                         ADV: 'ADV en ERREUR',
                         Croisement: 'ERREUR',
                         Écartement: 'ERREUR',
                         "Attaches / Rails": 'ERREUR',
                         "Bois / Joints": 'ERREUR',
                         "Demi-Aiguillage": 'ERREUR'
                     });
                 }
             });

             // 4. Affichage du tableau final
             console.table(resultatsLot);
             if (callbackPDF && typeof callbackPDF === 'function') {
                 callbackPDF(resultatsLot); 
             }
             return resultatsLot;
         }
        
         function coordonnerAffichageNotes(notesHorsDa, notesDA) {
            if (!notesHorsDa) {
                console.error("Coordinateur: Les notes ADV principales sont manquantes.");
                return;
            }

            const isTO = notesHorsDa.advType === 'TO';
            
            // Si notesDA est null/undefined, on le marque comme 'inconnu' ou 'N/A' selon le type
            const notesDAFinal = isTO 
                ? { demi_aiguillage: 'N/A (TO)' } 
                : (notesDA || { demi_aiguillage: 'inconnu' });

            const tableauFinal = {
                advName: notesHorsDa.advName,
                advType: notesHorsDa.advType,
                ...notesHorsDa,
                ...notesDAFinal
            };
            
            calculerTableauGlobal(tableauFinal);
        }

        async function lancerCalculGlobalPourTest(name, type) {
            const advName = name.trim();
            const advType = type.trim().toLowerCase();
            const encodedName = encodeURIComponent(advName);

            console.log(`--- Démarrage du Calcul Global pour ${advName} (${advType.toUpperCase()}) ---`);

            if (Object.keys(seuilsTransformed).length === 0) {
                console.error("ATTENTION: Les seuils ne sont pas encore chargés. Attendez le chargement initial.");
                return;
            }
            
            // Promesses pour les deux appels API
            const advDataPromise = fetch(`/api/${advType}/${encodedName}`)
                .then(res => {
                    if (!res.ok) throw new Error(`Erreur HTTP (ADV): ${res.status}`);
                    return res.json();
                })
                .then(data => Array.isArray(data) ? data[0] : data)
                .catch(err => {
                    console.error(`Erreur chargement ADV (${advName}):`, err);
                    return null;
                });

            let daDataPromise = Promise.resolve(null);

            // Charger les données DA seulement pour BS et TJ
            if (advType === 'bs' || advType === 'tj') {
                daDataPromise = fetch(`/api/da?adv=${encodedName}`)
                    .then(res => {
                        if (!res.ok) throw new Error(`Erreur HTTP (DA): ${res.status}`);
                        return res.json();
                    })
                    .catch(err => {
                        console.error(`Erreur chargement données DA pour ${advName}:`, err);
                        return []; // Retourne un tableau vide en cas d'erreur de DA
                    });
            }

            // Attendre que les deux appels soient terminés
            const [advData, dataDA] = await Promise.all([advDataPromise, daDataPromise]);

            if (!advData) {
                console.error(`Calcul interrompu: Données ADV principales pour ${advName} non disponibles.`);
                return;
            }

            // 1. Calcul des notes HORS DA
            const notesHorsDa = calculNoteHorsDa(advData);

            // 2. Calcul des notes DA
            let notesDA = null;
            if (advType === 'bs' || advType === 'tj') {
                if (dataDA && dataDA.length > 0) {
                    notesDA = calculNoteDa(dataDA, advType);
                } else {
                    // Si l'ADV est BS/TJ mais que l'API DA ne retourne rien
                    notesDA = { demi_aiguillage: 'inconnu' }; 
                }
            }

            // 3. Coordination et affichage
            coordonnerAffichageNotes(notesHorsDa, notesDA);
            console.log("--- Fin du Calcul Global ---");
        }
    </script>
</body>
</html>
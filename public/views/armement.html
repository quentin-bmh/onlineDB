<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Table Éditable avec Historique</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    table { border-collapse: collapse; width: 100%; margin-bottom: 20px; table-layout: fixed;; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
    th { background: #f4f4f4; }
    td.editing { background: #fffbe6; }
    td[contenteditable="true"]:hover { background: #f0faff; cursor: pointer; }
    input.cell-editor {
      width: 100%; box-sizing: border-box; padding: 6px;
      border: 1px solid #aaa; border-radius: 4px;
      font: inherit; text-align: center;
    }
    #saveBtn { padding: 10px 20px; background: #4CAF50; color: white;
      border: none; border-radius: 6px; cursor: pointer; font-weight: bold; }
    #saveBtn:hover { background: #45a049;  }
    #history {
      border: 1px solid #ccc; padding: 10px; border-radius: 6px;
      max-height: 200px; overflow-y: auto; background: #fafafa;
    }
    #history h3 { margin-top: 0; }
    .log-entry { font-size: 0.9em; margin: 4px 0; }
    .log-entry span { font-weight: bold; }
#tutorial-overlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: rgba(0,0,0,0.5);
  display: none;
  z-index: 1000; /* overlay au milieu */
}

.tutorial-highlight {
  position: relative !important;
  z-index: 2000 !important;     /* > overlay (1000) mais < fake-cursor (3000) */
  box-shadow: 0 8px 30px rgba(0,0,0,0.45);
  border-radius: 4px;
  background-clip: padding-box;
}
.fake-cursor {
  position: fixed;              /* fixe par rapport à la fenêtre */
  width: 32px;
  height: 32px;
  background: url('/assets/cursor.png') no-repeat center;
  background-size: contain;
  pointer-events: none;         /* ne bloque pas les clics */
  z-index: 3000;                /* plus haut que overlay et que les éléments highlight */
  transform: translate(-50%, -50%); /* centrer précisément sur coords */
}

  /* Animation déplacement */
  @keyframes moveToCell {
    0% { top: 80%; left: 50%; }
    50% { top: 40%; left: 30%; } /* exemple position d'une cellule */
    100% { top: 80%; left: 60%; } /* bouton enregistrer */
  }
  .animate {
    animation: moveToCell 5s linear forwards;
  }
  </style>
</head>
<body>
  <table id="myTable">
    <thead>
      <tr>
        <th>Id</th>
        <th data-editable="true">Nom</th>
        <th data-editable="true" data-type="number">Quantité</th>
        <th data-editable="true">Protection de pointe</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>1</td><td>ADV_1</td><td>10</td><td>1423</td></tr>
      <tr><td>2</td><td>ADV_2</td><td>5</td><td>1432</td></tr>
      <tr><td>3</td><td>ADV_3</td><td>12</td><td>1428</td></tr>
    </tbody>
  </table>

  <button id="saveBtn">Enregistrer les modifications</button>

  <div id="history">
    <h3>Historique des modifications</h3>
    <div id="historyLogs"></div>
  </div>
  <div class="nouv-mesure-container">
  <button id="new-measure-btn">Nouvelles mesures</button>
  <div id="tooltip" class="tooltip"></div>
</div>

<!-- Overlay tutoriel -->
<div id="fake-cursor" class="fake-cursor" style="left:-50px; top:-50px;"></div>
<div id="tutorial-overlay">
</div>
 <script>
const table = document.getElementById("myTable");
const historyLogs = document.getElementById("historyLogs");
let changes = [];

function isColumnEditable(colIndex) {
  const th = table.querySelectorAll("thead th")[colIndex];
  return th && th.dataset.editable === "true";
}

function columnType(colIndex) {
  const th = table.querySelectorAll("thead th")[colIndex];
  return th?.dataset.type || "text";
}

function editCell(td) {
  if (td.classList.contains("editing")) return;
  const colIndex = [...td.parentNode.children].indexOf(td);
  if (!isColumnEditable(colIndex)) return;

  const oldValue = td.textContent.trim();
  td.classList.add("editing");
  td.innerHTML = "";

  const input = document.createElement("input");
  input.type = "text";
  input.className = "cell-editor";
  input.value = oldValue;
  td.appendChild(input);
  input.focus();
  input.select();

  function commit() {
    let newValue = input.value.trim();
    const type = columnType(colIndex);
    if (type === "number" && isNaN(newValue)) {
      alert("Veuillez entrer un nombre valide");
      input.focus();
      return;
    }
    td.classList.remove("editing");
    td.innerHTML = newValue;

    if (newValue !== oldValue) {
      const rowId = td.parentNode.firstChild.textContent;
      changes.push({
        id: rowId,
        column: table.querySelectorAll("thead th")[colIndex].textContent,
        oldValue,
        newValue,
        timestamp: new Date().toLocaleString()
      });
      logChange(rowId, colIndex, oldValue, newValue);
    }
  }

  function cancel() {
    td.classList.remove("editing");
    td.innerHTML = oldValue;
  }

  input.addEventListener("blur", commit);
  input.addEventListener("keydown", (e) => {
    if (e.key === "Enter") commit();
    if (e.key === "Escape") cancel();
  });
}

table.addEventListener("dblclick", (e) => {
  const td = e.target.closest("td");
  if (!td || !table.contains(td)) return;
  editCell(td);
});

function logChange(rowId, colIndex, oldValue, newValue) {
  const colName = table.querySelectorAll("thead th")[colIndex].textContent;
  const entry = document.createElement("div");
  entry.className = "log-entry";
  entry.innerHTML = `<span>Ligne ${rowId}, Colonne "${colName}" :</span> "${oldValue}" → "${newValue}"`;
  historyLogs.prepend(entry);
}

document.getElementById("saveBtn").addEventListener("click", () => {
  if (changes.length === 0) return;
  console.log("Enregistrement des changements :", changes);
  alert("✅ Modifications enregistrées !");
  changes = [];
});

// --- Tutoriel animé avec bouton "Skip" ---
const newMeasureBtn = document.getElementById("new-measure-btn");
const overlay = document.getElementById("tutorial-overlay");
const fakeCursor = document.getElementById("fake-cursor");

// Style du curseur pour être toujours au-dessus
fakeCursor.style.position = "fixed";
fakeCursor.style.width = "32px";
fakeCursor.style.height = "32px";
fakeCursor.style.pointerEvents = "none";
fakeCursor.style.zIndex = "9999";

// Ajouter bouton Skip
let skipBtn = document.createElement("button");
skipBtn.textContent = "Skip Tutorial";
skipBtn.style.position = "absolute";
skipBtn.style.bottom = "20px";
skipBtn.style.right = "20px";
skipBtn.style.padding = "10px 15px";
skipBtn.style.background = "#f44336";
skipBtn.style.color = "white";
skipBtn.style.border = "none";
skipBtn.style.borderRadius = "6px";
skipBtn.style.cursor = "pointer";
overlay.appendChild(skipBtn);

newMeasureBtn.addEventListener("click", () => {
  overlay.style.display = "block";

  const cell = table.querySelector("tbody tr:first-child td:nth-child(3)");
  const saveBtn = document.getElementById("saveBtn");
  const originalValue = cell.textContent;
  let skipTutorial = false;

  function endTutorial() {
    skipTutorial = true;
    overlay.style.display = "none";
    cell.innerHTML = originalValue;
    setCursor("/assets/cursor.png");
  }

  // Skip avec bouton
  skipBtn.onclick = (e) => {
    e.stopPropagation();
    endTutorial();
  };

  // Skip en cliquant sur l'overlay
  overlay.onclick = (e) => {
    if (e.target === overlay) {
      endTutorial();
    }
  };

  function setCursor(image) {
    fakeCursor.style.background = `url('${image}') no-repeat center`;
    fakeCursor.style.backgroundSize = "contain";
  }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

  async function moveCursorTo(element, duration = 1000) {
    return new Promise(resolve => {
      const rect = element.getBoundingClientRect();
      const startX = parseFloat(fakeCursor.style.left || 0);
      const startY = parseFloat(fakeCursor.style.top || 0);
      const endX = rect.left + rect.width / 2 + window.scrollX + 25;
      const endY = rect.top + rect.height / 2 + window.scrollY + 15;
      const startTime = performance.now();

      function animate(time) {
        const elapsed = time - startTime;
        const progress = Math.min(elapsed / duration, 1);
        fakeCursor.style.left = startX + (endX - startX) * progress + "px";
        fakeCursor.style.top = startY + (endY - startY) * progress + "px";

        if (progress < 1 && !skipTutorial) {
          requestAnimationFrame(animate);
        } else {
          resolve();
        }
      }
      requestAnimationFrame(animate);
    });
  }

  async function runTutorial() {
    // Reset initial
    cell.classList.remove("editing");
    cell.innerHTML = originalValue;

    // Mettre cellule et bouton en avant
    cell.style.position = "relative";
    cell.style.zIndex = "20";
    saveBtn.style.position = "relative";
    saveBtn.style.zIndex = "20";

    fakeCursor.style.left = "-30px";
    fakeCursor.style.top = "+1000px";
    setCursor("/assets/cursor.png");

    if (skipTutorial) return;

    // Déplacer vers la cellule
    await moveCursorTo(cell, 1000);
    if (skipTutorial) return;

    // Double clic simulé
    for (let i = 0; i < 2; i++) {
      setCursor("/assets/cursor_click.png");
      await new Promise(r => setTimeout(r, 300));
      setCursor("/assets/cursor.png");
      await new Promise(r => setTimeout(r, 200));
    }
    if (skipTutorial) return;

    // Modifier cellule
    cell.classList.add("editing");
    cell.innerHTML = `<input type="text" class="cell-editor" value="${originalValue}">`;
    const input = cell.querySelector("input");
    input.focus();
    input.select();

    await new Promise(r => setTimeout(r, 1000));
    if (skipTutorial) return;

    input.value = "784";
    input.dispatchEvent(new Event("change"));
    input.blur();

    // Déplacer vers bouton Enregistrer
    await moveCursorTo(saveBtn, 1000);
    if (skipTutorial) return;

    setCursor("/assets/cursor_click.png");
    await new Promise(r => setTimeout(r, 400));
    saveBtn.click();

    // Reset styles
    cell.innerHTML = originalValue;
    cell.style.position = "";
    cell.style.zIndex = "";
    saveBtn.style.position = "";
    saveBtn.style.zIndex = "";

    if (!skipTutorial) {
      await new Promise(r => setTimeout(r, 1000));
      runTutorial();
    }
  }

  runTutorial();
});
</script>



</body>
</html>
